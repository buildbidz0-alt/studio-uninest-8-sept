-- Note: This file is not automatically executed. It's a reference for your database schema.
-- You can use a GUI like Supabase Studio or a migration tool to apply these changes.

-- Profiles table
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  website text,
  handle text unique,
  bio text,
  role text default 'student',
  banner_url text,
  contact_number text,
  opening_hours text,
  vendor_categories text[]
);

-- Enable Row Level Security
alter table profiles enable row level security;

-- Policies for profiles
create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

create policy "Users can update their own profile." on profiles
  for update using (auth.uid() = id);


-- Posts table (for social feed)
create table posts (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles not null,
  content text not null,
  created_at timestamp with time zone default now() not null
);
alter table posts enable row level security;
create policy "Users can create posts." on posts for insert with check (auth.uid() = user_id);
create policy "Users can update their own posts." on posts for update using (auth.uid() = user_id);
create policy "Users can delete their own posts." on posts for delete using (auth.uid() = user_id);
create policy "Posts are viewable by everyone." on posts for select using (true);


-- Likes table
create table likes (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles not null,
  post_id bigint references public.posts not null on delete cascade,
  created_at timestamp with time zone default now() not null,
  unique(user_id, post_id)
);
alter table likes enable row level security;
create policy "Users can like posts." on likes for insert with check (auth.uid() = user_id);
create policy "Users can unlike posts." on likes for delete using (auth.uid() = user_id);
create policy "Likes are viewable by everyone." on likes for select using (true);


-- Comments table
create table comments (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles not null,
  post_id bigint references public.posts not null on delete cascade,
  content text not null,
  created_at timestamp with time zone default now() not null
);
alter table comments enable row level security;
create policy "Users can add comments." on comments for insert with check (auth.uid() = user_id);
create policy "Users can update their own comments." on comments for update using (auth.uid() = user_id);
create policy "Users can delete their own comments." on comments for delete using (auth.uid() = user_id);
create policy "Comments are viewable by everyone." on comments for select using (true);

-- Followers table
create table followers (
  id bigint generated by default as identity primary key,
  follower_id uuid references public.profiles not null,
  following_id uuid references public.profiles not null,
  created_at timestamp with time zone default now() not null,
  unique(follower_id, following_id)
);
alter table followers enable row level security;
create policy "Users can follow others." on followers for insert with check (auth.uid() = follower_id);
create policy "Users can unfollow." on followers for delete using (auth.uid() = follower_id);
create policy "Follows are public." on followers for select using (true);


-- Chat Rooms
create table chat_rooms (
    id uuid primary key default gen_random_uuid(),
    created_at timestamp with time zone default now() not null
);
alter table chat_rooms enable row level security;
create policy "Chat rooms are viewable by participants." on chat_rooms for select using (exists (
    select 1 from chat_room_participants where room_id = id and user_id = auth.uid()
));

-- Chat Room Participants
create table chat_room_participants (
    id bigint generated by default as identity primary key,
    room_id uuid references public.chat_rooms not null on delete cascade,
    user_id uuid references public.profiles not null,
    created_at timestamp with time zone default now() not null,
    unique(room_id, user_id)
);
alter table chat_room_participants enable row level security;
create policy "Users can manage their own participation." on chat_room_participants for all using (auth.uid() = user_id);
create policy "Participants can view other participants." on chat_room_participants for select using (exists (
    select 1 from chat_room_participants where room_id = chat_room_participants.room_id and user_id = auth.uid()
));

-- Chat Messages
create table chat_messages (
    id bigint generated by default as identity primary key,
    room_id uuid references public.chat_rooms not null on delete cascade,
    user_id uuid references public.profiles not null,
    content text not null,
    created_at timestamp with time zone default now() not null
);
alter table chat_messages enable row level security;
create policy "Participants can send messages." on chat_messages for insert with check (exists (
    select 1 from chat_room_participants where room_id = chat_messages.room_id and user_id = auth.uid()
));
create policy "Participants can view messages." on chat_messages for select using (exists (
    select 1 from chat_room_participants where room_id = chat_messages.room_id and user_id = auth.uid()
));


-- Products (for marketplace)
create table products (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    name text not null,
    description text not null,
    price numeric not null check (price >= 0),
    image_url text,
    category text not null,
    seller_id uuid not null references public.profiles
);
alter table products enable row level security;
create policy "Products are viewable by everyone." on products for select using (true);
create policy "Users can insert their own products." on products for insert with check (auth.uid() = seller_id);
create policy "Users can update their own products." on products for update with check (auth.uid() = seller_id);
create policy "Users can delete their own products." on products for delete using (auth.uid() = seller_id);


-- Orders
create table orders (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    buyer_id uuid not null references public.profiles,
    vendor_id uuid not null references public.profiles,
    total_amount numeric not null check (total_amount >= 0),
    status text default 'Pending',
    razorpay_payment_id text
);
alter table orders enable row level security;
create policy "Users can view their own orders." on orders for select using (auth.uid() = buyer_id or auth.uid() = vendor_id);
create policy "Users can create orders." on orders for insert with check (auth.uid() = buyer_id);


-- Order Items
create table order_items (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    product_id bigint not null references public.products,
    quantity integer not null check (quantity > 0),
    price numeric not null
);
alter table order_items enable row level security;
create policy "Users can view their own order items." on order_items for select using (
    exists (select 1 from orders where id = order_items.order_id)
);
create policy "Users can create their own order items." on order_items for insert with check (
    exists (select 1 from orders where id = order_items.order_id and buyer_id = auth.uid())
);


-- Function to create a chat room if it doesn't exist
create or replace function get_or_create_chat_room(p_user_id1 uuid, p_user_id2 uuid)
returns uuid as $$
declare
    v_room_id uuid;
begin
    select room_id into v_room_id
    from chat_room_participants p1
    join chat_room_participants p2 on p1.room_id = p2.room_id
    where p1.user_id = p_user_id1 and p2.user_id = p_user_id2;

    if v_room_id is null then
        insert into chat_rooms (id) values (default) returning id into v_room_id;
        insert into chat_room_participants (room_id, user_id) values (v_room_id, p_user_id1), (v_room_id, p_user_id2);
    end if;

    return v_room_id;
end;
$$ language plpgsql volatile security definer;


-- Notifications Table
create table notifications (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid references public.profiles not null,
    sender_id uuid references public.profiles not null,
    type text not null, -- e.g., 'new_follower', 'new_post_like', 'new_comment'
    post_id bigint references public.posts,
    is_read boolean default false
);
alter table notifications enable row level security;
create policy "Users can view their own notifications" on notifications for select using (auth.uid() = user_id);
create policy "Users can update their own notifications" on notifications for update using (auth.uid() = user_id);

-- Function to create notification on new follower
create or replace function public.handle_new_follower()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.notifications (user_id, sender_id, type)
  values (new.following_id, new.follower_id, 'new_follower');
  return new;
end;
$$;

-- Trigger for new followers
create trigger on_new_follower
  after insert on public.followers
  for each row execute procedure public.handle_new_follower();


-- Competitions Table
create table competitions (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    title text not null,
    description text not null,
    prize numeric not null check (prize >= 0),
    deadline timestamp with time zone not null,
    entry_fee numeric not null check (entry_fee >= 0),
    image_url text,
    details_pdf_url text
);
alter table competitions enable row level security;
create policy "Competitions are viewable by everyone." on competitions for select using (true);
create policy "Admins can manage competitions" on competitions for all using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);


-- Competition Entries Table
create table competition_entries (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid not null references public.profiles,
    competition_id bigint not null references public.competitions on delete cascade,
    razorpay_payment_id text,
    unique(user_id, competition_id)
);
alter table competition_entries enable row level security;
create policy "Users can view their own entries." on competition_entries for select using (auth.uid() = user_id);
create policy "Users can create entries." on competition_entries for insert with check (auth.uid() = user_id);
create policy "Admins can view all entries." on competition_entries for select using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);


-- Internships Table
create table internships (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    role text not null,
    company text not null,
    stipend numeric not null check (stipend >= 0),
    stipend_period text,
    location text not null,
    deadline timestamp with time zone not null,
    image_url text,
    details_pdf_url text
);
alter table internships enable row level security;
create policy "Internships are viewable by everyone." on internships for select using (true);
create policy "Admins can manage internships" on internships for all using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);


-- Donations Table
create table donations (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid not null references public.profiles,
    amount numeric not null check (amount > 0),
    currency text not null default 'INR',
    razorpay_payment_id text unique
);
alter table donations enable row level security;
create policy "Donations are viewable by everyone." on donations for select using (true);
create policy "Users can make donations." on donations for insert with check (auth.uid() = user_id);


-- App Config table
create table app_config (
    key text primary key,
    value jsonb
);
alter table app_config enable row level security;
create policy "Config is public" on app_config for select using (true);
create policy "Admins can manage config" on app_config for all using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);
insert into app_config (key, value) values ('donation_goal', '50000');


-- Platform Settings table
create table platform_settings (
    key text primary key,
    value jsonb
);
alter table platform_settings enable row level security;
create policy "Settings are public" on platform_settings for select using (true);
create policy "Admins can manage settings" on platform_settings for all using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);
insert into platform_settings (key, value) values ('monetization', '{ "charge_for_posts": false, "post_price": 10, "start_date": null }');

-- Audit Log table
create table audit_log (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    admin_id uuid references public.profiles,
    action text not null,
    details text
);
alter table audit_log enable row level security;
create policy "Admins can view audit logs" on audit_log for select using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);
create policy "Admins can insert audit logs" on audit_log for insert with check (
    auth.uid() = admin_id and (select role from public.profiles where id = auth.uid()) = 'admin'
);

-- Support Tickets Table
create table support_tickets (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,
  user_id uuid references public.profiles not null,
  category text not null,
  subject text not null,
  description text not null,
  status text default 'Open' not null,
  priority text default 'Medium' not null,
  screenshot_url text
);
alter table support_tickets enable row level security;
create policy "Users can create and view their own tickets." on support_tickets for all using (auth.uid() = user_id);
create policy "Admins can view and manage all tickets." on support_tickets for all using (
    (select role from public.profiles where id = auth.uid()) = 'admin'
);


-- Function to get user chat rooms with participant info
create or replace function get_user_chat_rooms(p_user_id uuid)
returns table (
    id uuid,
    created_at timestamptz,
    name text,
    avatar text,
    last_message text,
    last_message_timestamp timestamptz
) as $$
begin
    return query
    with user_rooms as (
        select room_id from chat_room_participants where user_id = p_user_id
    ),
    other_participants as (
        select
            ur.room_id,
            p.id as participant_id,
            p.full_name,
            p.avatar_url
        from user_rooms ur
        join chat_room_participants crp on ur.room_id = crp.room_id
        join profiles p on crp.user_id = p.id
        where crp.user_id != p_user_id
    ),
    last_messages as (
      select
        room_id,
        content,
        created_at,
        row_number() over (partition by room_id order by created_at desc) as rn
      from chat_messages
      where room_id in (select room_id from user_rooms)
    )
    select
        r.id,
        r.created_at,
        op.full_name as name,
        op.avatar_url as avatar,
        lm.content as last_message,
        lm.created_at as last_message_timestamp
    from chat_rooms r
    join other_participants op on r.id = op.room_id
    left join last_messages lm on r.id = lm.room_id and lm.rn = 1
    where r.id in (select room_id from user_rooms)
    order by lm.created_at desc nulls last, r.created_at desc;
end;
$$ language plpgsql;
