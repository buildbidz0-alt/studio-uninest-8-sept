
-- Drop existing tables to start fresh
DROP TABLE IF EXISTS "public"."order_items";
DROP TABLE IF EXISTS "public"."orders";
DROP TABLE IF EXISTS "public"."support_tickets";
DROP TABLE IF EXISTS "public"."donations";
DROP TABLE IF EXISTS "public"."notifications";
DROP TABLE IF EXISTS "public"."competition_entries";
DROP TABLE IF EXISTS "public"."competitions";
DROP TABLE IF EXISTS "public"."internships";
DROP TABLE IF EXISTS "public"."chat_messages";
DROP TABLE IF EXISTS "public"."chat_participants";
DROP TABLE IF EXISTS "public"."chat_rooms";
DROP TABLE IF EXISTS "public"."followers";
DROP TABLE IF EXISTS "public"."likes";
DROP TABLE IF EXISTS "public"."comments";
DROP TABLE IF EXISTS "public"."posts";
DROP TABLE IF EXISTS "public"."products";
DROP TABLE IF EXISTS "public"."audit_log";
DROP TABLE IF EXISTS "public"."platform_settings";
DROP TABLE IF EXISTS "public"."app_config";
DROP TABLE IF EXISTS "public"."profiles";

-- Create Profiles table
CREATE TABLE profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    full_name text,
    avatar_url text,
    handle text UNIQUE,
    bio text,
    role text DEFAULT 'student',
    vendor_categories text[],
    banner_url text,
    contact_number text,
    opening_hours text
);
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON profiles FOR UPDATE USING (auth.uid() = id);

-- Function to create a public profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, full_name, avatar_url, handle, role, vendor_categories)
    VALUES (
        new.id,
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'avatar_url',
        new.raw_user_meta_data->>'handle',
        new.raw_user_meta_data->>'role',
        (SELECT array_agg(elem::text) FROM jsonb_array_elements_text(new.raw_user_meta_data->'vendor_categories') AS elem)
    );
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function on new user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create Products table
CREATE TABLE products (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone not null default now(),
    name text not null,
    description text not null,
    price real not null,
    image_url text,
    category text not null,
    seller_id uuid not null references public.profiles(id) on delete cascade
);
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Products are viewable by everyone." ON products FOR SELECT USING (true);
CREATE POLICY "Users can insert their own products." ON products FOR INSERT WITH CHECK (auth.uid() = seller_id);
CREATE POLICY "Users can update their own products." ON products FOR UPDATE USING (auth.uid() = seller_id);
CREATE POLICY "Users can delete their own products." ON products FOR DELETE USING (auth.uid() = seller_id);

-- Create Posts table
CREATE TABLE posts (
    id bigint generated by default as identity primary key,
    content text not null,
    created_at timestamp with time zone not null default now(),
    user_id uuid not null references public.profiles(id) on delete cascade
);
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Posts are viewable by everyone." ON posts FOR SELECT USING (true);
CREATE POLICY "Users can create their own posts." ON posts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own posts." ON posts FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own posts." ON posts FOR DELETE USING (auth.uid() = user_id);
CREATE POLICY "Admins can manage all posts." ON posts FOR ALL USING (public.is_admin());

-- Create Likes table
CREATE TABLE likes (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    post_id bigint not null references public.posts(id) on delete cascade,
    created_at timestamp with time zone not null default now(),
    unique(user_id, post_id)
);
ALTER TABLE likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Likes are viewable by everyone." ON likes FOR SELECT USING (true);
CREATE POLICY "Users can manage their own likes." ON likes FOR ALL USING (auth.uid() = user_id);

-- Create Comments table
CREATE TABLE comments (
    id bigint generated by default as identity primary key,
    content text not null,
    user_id uuid not null references public.profiles(id) on delete cascade,
    post_id bigint not null references public.posts(id) on delete cascade,
    created_at timestamp with time zone not null default now()
);
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Comments are viewable by everyone." ON comments FOR SELECT USING (true);
CREATE POLICY "Users can manage their own comments." ON comments FOR ALL USING (auth.uid() = user_id);

-- Create Followers table
CREATE TABLE followers (
    id bigint generated by default as identity primary key,
    follower_id uuid not null references public.profiles(id) on delete cascade,
    following_id uuid not null references public.profiles(id) on delete cascade,
    created_at timestamp with time zone not null default now(),
    unique(follower_id, following_id)
);
ALTER TABLE followers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Follower relationships are public." ON followers FOR SELECT USING (true);
CREATE POLICY "Users can manage their own follows." ON followers FOR ALL USING (auth.uid() = follower_id);

-- Create Chat Rooms tables
CREATE TABLE chat_rooms (
    id uuid default gen_random_uuid() primary key,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
ALTER TABLE chat_rooms ENABLE ROW LEVEL SECURITY;

CREATE TABLE chat_participants (
    id bigint generated by default as identity primary key,
    room_id uuid references public.chat_rooms(id) on delete cascade not null,
    user_id uuid references public.profiles(id) on delete cascade not null,
    unique(room_id, user_id)
);
ALTER TABLE chat_participants ENABLE ROW LEVEL SECURITY;

CREATE TABLE chat_messages (
    id bigint generated by default as identity primary key,
    room_id uuid references public.chat_rooms(id) on delete cascade not null,
    user_id uuid references public.profiles(id) on delete cascade not null,
    content text not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;

-- Secure Chat Policies
CREATE POLICY "Users can view rooms they are in." ON chat_rooms FOR SELECT USING (
    id IN (
        SELECT room_id FROM chat_participants WHERE user_id = auth.uid()
    )
);

CREATE POLICY "Users can view participants of rooms they are in." ON chat_participants FOR SELECT USING (
    room_id IN (
        SELECT room_id FROM chat_participants WHERE user_id = auth.uid()
    )
);

CREATE POLICY "Users can view messages in rooms they are in." ON chat_messages FOR SELECT USING (
    room_id IN (
        SELECT room_id FROM chat_participants WHERE user_id = auth.uid()
    )
);

CREATE POLICY "Users can insert messages in rooms they are in." ON chat_messages FOR INSERT WITH CHECK (
    room_id IN (
        SELECT room_id FROM chat_participants WHERE user_id = auth.uid()
    )
);
CREATE POLICY "Users can create chat participants for rooms they are in." ON chat_participants FOR INSERT WITH CHECK (
    room_id IN (
        SELECT room_id FROM chat_participants WHERE user_id = auth.uid()
    )
);

-- Database function to get or create a chat room
CREATE OR REPLACE FUNCTION public.get_or_create_chat_room(p_user_id1 uuid, p_user_id2 uuid)
RETURNS uuid AS $$
DECLARE
    existing_room_id uuid;
    new_room_id uuid;
BEGIN
    SELECT room_id INTO existing_room_id
    FROM chat_participants cp1
    JOIN chat_participants cp2 ON cp1.room_id = cp2.room_id
    WHERE cp1.user_id = p_user_id1 AND cp2.user_id = p_user_id2;

    IF existing_room_id IS NOT NULL THEN
        RETURN existing_room_id;
    END IF;

    INSERT INTO chat_rooms DEFAULT VALUES RETURNING id INTO new_room_id;
    INSERT INTO chat_participants (room_id, user_id) VALUES (new_room_id, p_user_id1);
    INSERT INTO chat_participants (room_id, user_id) VALUES (new_room_id, p_user_id2);

    RETURN new_room_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get last message
CREATE OR REPLACE FUNCTION public.get_last_messages_for_rooms(p_room_ids uuid[])
RETURNS TABLE(room_id uuid, content text, created_at timestamptz) AS $$
BEGIN
    RETURN QUERY
    SELECT m.room_id, m.content, m.created_at
    FROM chat_messages m
    JOIN (
        SELECT room_id, MAX(created_at) as max_created_at
        FROM chat_messages
        WHERE room_id = ANY(p_room_ids)
        GROUP BY room_id
    ) lm ON m.room_id = lm.room_id AND m.created_at = lm.max_created_at;
END;
$$ LANGUAGE plpgsql STABLE;

-- Donations table
CREATE TABLE donations (
    id bigint generated by default as identity primary key,
    user_id uuid references public.profiles(id),
    amount integer not null,
    currency character varying(3) not null,
    created_at timestamp with time zone default now() not null,
    razorpay_payment_id text
);
ALTER TABLE donations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Donations are public." ON donations FOR SELECT USING (true);
CREATE POLICY "Users can make donations." ON donations FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Config tables
CREATE TABLE app_config (
    id bigint generated by default as identity primary key,
    key text unique not null,
    value text
);
CREATE TABLE platform_settings (
    id bigint generated by default as identity primary key,
    key text unique not null,
    value jsonb
);
ALTER TABLE app_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE platform_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Config is public." ON app_config FOR SELECT USING (true);
CREATE POLICY "Settings are public." ON platform_settings FOR SELECT USING (true);
CREATE POLICY "Admins can manage config." ON app_config FOR ALL USING (public.is_admin());
CREATE POLICY "Admins can manage settings." ON platform_settings FOR ALL USING (public.is_admin());

-- Notifications table
CREATE TABLE notifications (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid references public.profiles on delete cascade not null,
    sender_id uuid references public.profiles on delete cascade not null,
    type text not null,
    post_id bigint references public.posts on delete cascade,
    is_read boolean default false not null
);
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own notifications." ON notifications FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can update their own notifications." ON notifications FOR UPDATE USING (auth.uid() = user_id);

-- Competitions tables
CREATE TABLE competitions (
    id bigint generated by default as identity primary key,
    title text not null,
    description text,
    prize numeric not null,
    entry_fee numeric not null default 0,
    deadline timestamp with time zone not null,
    image_url text,
    details_pdf_url text,
    created_at timestamp with time zone default now() not null
);
CREATE TABLE competition_entries (
    id bigint generated by default as identity primary key,
    competition_id bigint references public.competitions on delete cascade not null,
    user_id uuid references public.profiles on delete cascade not null,
    razorpay_payment_id text,
    created_at timestamp with time zone default now() not null,
    unique(competition_id, user_id)
);
ALTER TABLE competitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE competition_entries ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Competitions are public." ON competitions FOR SELECT USING (true);
CREATE POLICY "Admins can manage competitions." ON competitions FOR ALL USING (public.is_admin());
CREATE POLICY "Competition entries are public." ON competition_entries FOR SELECT USING (true);
CREATE POLICY "Users can manage their own entries." ON competition_entries FOR ALL USING (auth.uid() = user_id);

-- Internships table
CREATE TABLE internships (
    id bigint generated by default as identity primary key,
    role text not null,
    company text not null,
    stipend numeric not null,
    stipend_period text,
    location text not null,
    deadline timestamp with time zone not null,
    image_url text,
    details_pdf_url text,
    created_at timestamp with time zone default now() not null
);
ALTER TABLE internships ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Internships are public." ON internships FOR SELECT USING (true);
CREATE POLICY "Admins can manage internships." ON internships FOR ALL USING (public.is_admin());

-- Support Tickets table
CREATE TABLE support_tickets (
    id bigint generated by default as identity primary key,
    user_id uuid references public.profiles on delete cascade not null,
    category text not null,
    subject text not null,
    description text not null,
    status text default 'Open' not null,
    priority text default 'Medium' not null,
    screenshot_url text,
    created_at timestamp with time zone default now() not null
);
ALTER TABLE support_tickets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own tickets." ON support_tickets FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Admins can view all tickets." ON support_tickets FOR SELECT USING (public.is_admin());
CREATE POLICY "Admins can update all tickets." ON support_tickets FOR UPDATE USING (public.is_admin());

-- Audit Log table
CREATE TABLE audit_log (
    id bigint generated by default as identity primary key,
    admin_id uuid references public.profiles(id) on delete cascade not null,
    action text not null,
    details text,
    created_at timestamp with time zone default now() not null
);
ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can view audit logs." ON audit_log FOR SELECT USING (public.is_admin());

-- Orders tables
CREATE TABLE orders (
    id bigint generated by default as identity primary key,
    buyer_id uuid references public.profiles on delete set null,
    vendor_id uuid references public.profiles on delete set null,
    total_amount real not null,
    status text default 'Pending' not null,
    razorpay_payment_id text,
    created_at timestamp with time zone default now() not null
);
CREATE TABLE order_items (
    id bigint generated by default as identity primary key,
    order_id bigint references public.orders on delete cascade,
    product_id bigint references public.products on delete set null,
    quantity integer not null,
    price real not null
);
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own orders." ON orders FOR SELECT USING (auth.uid() = buyer_id OR auth.uid() = vendor_id);
CREATE POLICY "Users can create orders." ON orders FOR INSERT WITH CHECK (auth.uid() = buyer_id);
CREATE POLICY "Users can view items in their orders." ON order_items FOR SELECT USING (
    order_id IN (SELECT id FROM orders WHERE buyer_id = auth.uid() OR vendor_id = auth.uid())
);
CREATE POLICY "Users can create order items." ON order_items FOR INSERT WITH CHECK (
    order_id IN (SELECT id FROM orders WHERE buyer_id = auth.uid())
);

-- Function to check if user is admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
    RETURN (
        SELECT raw_user_meta_data->>'role'
        FROM auth.users
        WHERE id = auth.uid()
    ) = 'admin';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Insert initial data
INSERT INTO app_config (key, value) VALUES ('donation_goal', '50000') ON CONFLICT (key) DO NOTHING;
INSERT INTO platform_settings (key, value) VALUES ('monetization', '{"charge_for_posts": false, "post_price": 10, "start_date": null}') ON CONFLICT (key) DO NOTHING;
