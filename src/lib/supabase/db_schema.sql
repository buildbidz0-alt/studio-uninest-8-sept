
-- Drop existing policies and functions to start clean
drop policy if exists "Enable read access for all users" on "public"."profiles";
drop policy if exists "Users can insert their own profile." on "public"."profiles";
drop policy if exists "Users can update their own profile." on "public"."profiles";
drop policy if exists "Enable read access for all users" on "public"."posts";
drop policy if exists "Users can insert their own posts" on "public"."posts";
drop policy if exists "Users can update their own posts" on "public"."posts";
drop policy if exists "Users can delete their own posts" on "public"."posts";
drop policy if exists "Enable read for users you follow" on "public"."posts";
drop policy if exists "Enable read access for all users" on "public"."likes";
drop policy if exists "Users can insert their own likes" on "public"."likes";
drop policy if exists "Users can delete their own likes" on "public"."likes";
drop policy if exists "Enable read access for all users" on "public"."comments";
drop policy if exists "Users can insert their own comments" on "public"."comments";
drop policy if exists "Users can delete their own comments" on "public"."comments";
drop policy if exists "Enable read access for all users" on "public"."followers";
drop policy if exists "Users can insert their own follows" on "public"."followers";
drop policy if exists "Users can delete their own follows" on "public"."followers";
drop policy if exists "Enable read access for all users" on "public"."products";
drop policy if exists "Users can insert their own products" on "public"."products";
drop policy if exists "Users can update their own products" on "public"."products";
drop policy if exists "Users can delete their own products" on "public"."products";
drop policy if exists "Enable read for participants" on "public"."chat_messages";
drop policy if exists "Enable insert for participants" on "public"."chat_messages";
drop policy if exists "Enable read for participants" on "public"."chat_participants";
drop policy if exists "Enable read access for participants" on "public"."chat_rooms";

drop function if exists handle_new_user();
drop function if exists is_chat_participant(uuid, uuid);
drop function if exists get_or_create_chat_room(uuid, uuid);
drop function if exists get_last_messages_for_rooms(uuid[]);


-- Create tables
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  handle text unique,
  bio text,
  role text default 'student',
  banner_url text
);

create table if not exists public.posts (
  id bigint generated by default as identity primary key,
  content text not null,
  user_id uuid references public.profiles on delete cascade not null,
  created_at timestamp with time zone default now() not null
);

create table if not exists public.likes (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles on delete cascade not null,
  post_id bigint references public.posts on delete cascade not null,
  created_at timestamp with time zone default now() not null,
  unique(user_id, post_id)
);

create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  content text not null,
  user_id uuid references public.profiles on delete cascade not null,
  post_id bigint references public.posts on delete cascade not null,
  created_at timestamp with time zone default now() not null
);

create table if not exists public.followers (
    id bigint generated by default as identity primary key,
    follower_id uuid references public.profiles on delete cascade not null,
    following_id uuid references public.profiles on delete cascade not null,
    created_at timestamp with time zone default now() not null,
    unique(follower_id, following_id)
);

create table if not exists public.products (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    name text not null,
    description text,
    price numeric not null,
    image_url text,
    category text not null,
    seller_id uuid references public.profiles on delete cascade not null
);

create table if not exists public.chat_rooms (
    id uuid default gen_random_uuid() primary key,
    created_at timestamp with time zone default now() not null
);

create table if not exists public.chat_participants (
    id bigint generated by default as identity primary key,
    room_id uuid references public.chat_rooms on delete cascade not null,
    user_id uuid references public.profiles on delete cascade not null,
    created_at timestamp with time zone default now() not null,
    unique(room_id, user_id)
);

create table if not exists public.chat_messages (
    id bigint generated by default as identity primary key,
    content text not null,
    room_id uuid references public.chat_rooms on delete cascade not null,
    user_id uuid references public.profiles on delete cascade not null,
    created_at timestamp with time zone default now() not null
);

create table if not exists public.donations (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid references public.profiles on delete cascade,
    amount numeric not null,
    currency character varying(3) not null,
    razorpay_payment_id text unique
);

create table if not exists public.app_config (
    key text primary key,
    value text
);

create table if not exists public.orders (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    buyer_id uuid references public.profiles on delete cascade not null,
    vendor_id uuid references public.profiles on delete cascade not null,
    total_amount numeric not null,
    status text default 'Pending',
    razorpay_payment_id text unique
);

create table if not exists public.order_items (
    id bigint generated by default as identity primary key,
    order_id bigint references public.orders on delete cascade not null,
    product_id bigint references public.products on delete set null,
    quantity integer not null,
    price numeric not null
);

create table if not exists public.support_tickets (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid references public.profiles on delete cascade not null,
    category text not null,
    subject text not null,
    description text not null,
    status text default 'Open',
    priority text default 'Medium',
    screenshot_url text
);

create table if not exists public.platform_settings (
    key text primary key,
    value jsonb
);

create table if not exists public.competitions (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    title text not null,
    description text,
    prize numeric not null,
    entry_fee numeric not null,
    deadline timestamp with time zone not null,
    image_url text,
    details_pdf_url text
);

create table if not exists public.competition_entries (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid references public.profiles on delete cascade not null,
    competition_id bigint references public.competitions on delete cascade not null,
    razorpay_payment_id text,
    unique(user_id, competition_id)
);

create table if not exists public.internships (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    role text not null,
    company text not null,
    stipend numeric not null,
    stipend_period text,
    location text,
    deadline timestamp with time zone not null,
    image_url text,
    details_pdf_url text
);

create table if not exists public.audit_log (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    admin_id uuid references public.profiles on delete set null,
    action text not null,
    details text
);

create table if not exists public.notifications (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    user_id uuid references public.profiles on delete cascade not null,
    sender_id uuid references public.profiles on delete cascade not null,
    type text not null,
    post_id bigint references public.posts on delete cascade,
    is_read boolean default false
);


-- DB functions and triggers
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, avatar_url, handle, role)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    new.raw_user_meta_data->>'handle',
    new.raw_user_meta_data->>'role'
  );
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- New, correct RPC function for chat
CREATE OR REPLACE FUNCTION get_or_create_chat_room(p_user_id1 uuid, p_user_id2 uuid)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_room_id uuid;
BEGIN
    -- Find an existing room
    SELECT cp1.room_id INTO v_room_id
    FROM chat_participants cp1
    JOIN chat_participants cp2 ON cp1.room_id = cp2.room_id
    WHERE cp1.user_id = p_user_id1 AND cp2.user_id = p_user_id2
    LIMIT 1;

    -- If no room exists, create one
    IF v_room_id IS NULL THEN
        INSERT INTO chat_rooms (id) VALUES (gen_random_uuid()) RETURNING id INTO v_room_id;
        INSERT INTO chat_participants (room_id, user_id) VALUES (v_room_id, p_user_id1);
        INSERT INTO chat_participants (room_id, user_id) VALUES (v_room_id, p_user_id2);
    END IF;

    RETURN v_room_id;
END;
$$;

CREATE OR REPLACE FUNCTION get_last_messages_for_rooms(p_room_ids uuid[])
RETURNS TABLE(room_id uuid, content text, created_at timestamptz)
LANGUAGE sql
AS $$
    SELECT
        m.room_id,
        m.content,
        m.created_at
    FROM
        chat_messages m
    JOIN (
        SELECT
            room_id,
            MAX(created_at) as max_created_at
        FROM
            chat_messages
        WHERE
            room_id = ANY(p_room_ids)
        GROUP BY
            room_id
    ) lm ON m.room_id = lm.room_id AND m.created_at = lm.max_created_at
    WHERE m.room_id = ANY(p_room_ids);
$$;

-- RLS POLICIES --

-- Profiles
alter table public.profiles enable row level security;
create policy "Enable read access for all users" on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id);

-- Posts
alter table public.posts enable row level security;
create policy "Enable read access for all users" on public.posts for select using (true);
create policy "Users can insert their own posts" on public.posts for insert with check (auth.uid() = user_id);
create policy "Users can update their own posts" on public.posts for update using (auth.uid() = user_id);
create policy "Users can delete their own posts" on public.posts for delete using (auth.uid() = user_id);

-- Likes
alter table public.likes enable row level security;
create policy "Enable read access for all users" on public.likes for select using (true);
create policy "Users can insert their own likes" on public.likes for insert with check (auth.uid() = user_id);
create policy "Users can delete their own likes" on public.likes for delete using (auth.uid() = user_id);

-- Comments
alter table public.comments enable row level security;
create policy "Enable read access for all users" on public.comments for select using (true);
create policy "Users can insert their own comments" on public.comments for insert with check (auth.uid() = user_id);
create policy "Users can delete their own comments" on public.comments for delete using (auth.uid() = user_id or exists (select 1 from posts where posts.id = comments.post_id and posts.user_id = auth.uid()));

-- Followers
alter table public.followers enable row level security;
create policy "Enable read access for all users" on public.followers for select using (true);
create policy "Users can insert their own follows" on public.followers for insert with check (auth.uid() = follower_id);
create policy "Users can delete their own follows" on public.followers for delete using (auth.uid() = follower_id);

-- Products
alter table public.products enable row level security;
create policy "Enable read access for all users" on public.products for select using (true);
create policy "Users can insert their own products" on public.products for insert with check (auth.uid() = seller_id);
create policy "Users can update their own products" on public.products for update using (auth.uid() = seller_id);
create policy "Users can delete their own products" on public.products for delete using (auth.uid() = seller_id);

-- ** CORRECTED CHAT POLICIES **
alter table public.chat_rooms enable row level security;
alter table public.chat_participants enable row level security;
alter table public.chat_messages enable row level security;

create policy "Enable read for participants" on public.chat_rooms
    for select using (exists (
        select 1 from chat_participants where room_id = id and user_id = auth.uid()
    ));
    
create policy "Enable read for participants" on public.chat_participants
    for select using (exists (
        select 1 from chat_participants cp where cp.room_id = chat_participants.room_id and cp.user_id = auth.uid()
    ));

create policy "Enable insert for room creators" on public.chat_participants
    for insert with check (exists (
        select 1 from chat_rooms where id = room_id
    ));

create policy "Enable read for participants" on public.chat_messages
    for select using (exists (
        select 1 from chat_participants where room_id = chat_messages.room_id and user_id = auth.uid()
    ));

create policy "Enable insert for participants" on public.chat_messages
    for insert with check (exists (
        select 1 from chat_participants where room_id = chat_messages.room_id and user_id = auth.uid()
    ));

-- Other tables
alter table public.donations enable row level security;
create policy "Enable read access for all users" on public.donations for select using (true);
create policy "Enable insert for authenticated users" on public.donations for insert with check (auth.role() = 'authenticated');

alter table public.orders enable row level security;
create policy "Enable read for buyer or vendor" on public.orders for select using (auth.uid() = buyer_id or auth.uid() = vendor_id);
create policy "Enable insert for authenticated users" on public.orders for insert with check (auth.role() = 'authenticated');

alter table public.order_items enable row level security;
create policy "Enable read for order participants" on public.order_items for select using (exists (select 1 from orders where orders.id = order_id and (orders.buyer_id = auth.uid() or orders.vendor_id = auth.uid())));
create policy "Enable insert for order participants" on public.order_items for insert with check (exists (select 1 from orders where orders.id = order_id and orders.buyer_id = auth.uid()));

alter table public.support_tickets enable row level security;
create policy "Users can manage their own tickets" on public.support_tickets for all using (auth.uid() = user_id);
create policy "Admins can manage all tickets" on public.support_tickets for all using ((select role from public.profiles where id = auth.uid()) = 'admin');

-- Notifications
alter table public.notifications enable row level security;
create policy "Users can see their own notifications" on public.notifications for select using (auth.uid() = user_id);
create policy "Users can update their own notifications" on public.notifications for update using (auth.uid() = user_id);

-- Enable RLS for all other necessary tables that might be missing it
alter table public.app_config enable row level security;
create policy "Enable read for all users" on public.app_config for select using (true);
alter table public.platform_settings enable row level security;
create policy "Enable read for all users" on public.platform_settings for select using (true);
alter table public.competitions enable row level security;
create policy "Enable read for all users" on public.competitions for select using (true);
alter table public.competition_entries enable row level security;
create policy "Enable all for users" on public.competition_entries for all using (auth.uid() = user_id);
alter table public.internships enable row level security;
create policy "Enable read for all users" on public.internships for select using (true);
alter table public.audit_log enable row level security;
create policy "Enable read for admins" on public.audit_log for select using ((select role from public.profiles where id = auth.uid()) = 'admin');
