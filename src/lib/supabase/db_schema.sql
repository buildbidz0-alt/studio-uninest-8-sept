
-- Drop existing policies to start fresh
DROP POLICY IF EXISTS "Allow read access to all users" ON "public"."products";
DROP POLICY IF EXISTS "Allow insert for authenticated users" ON "public"."products";
DROP policy IF EXISTS "Allow update for users based on user_id" ON "public"."products";
DROP policy IF EXISTS "Allow delete for users based on user_id" ON "public"."products";
DROP policy IF EXISTS "Allow read access for a user's own profile" ON "public"."profiles";
DROP policy IF EXISTS "Allow update for a user's own profile" ON "public"."profiles";
DROP policy IF EXISTS "Enable read access for all users" ON "public"."profiles";
DROP policy IF EXISTS "Allow read access for user to their own notifications" ON "public"."notifications";
DROP policy IF EXISTS "Allow read access for user to their own likes" ON "public"."likes";
DROP policy IF EXISTS "Allow insert for authenticated users" ON "public"."likes";
DROP policy IF EXISTS "Allow delete for users based on user_id" ON "public"."likes";
DROP policy IF EXISTS "Allow read access for user to their own followers" ON "public"."followers";
DROP policy IF EXISTS "Allow insert for authenticated users" ON "public"."followers";
DROP policy IF EXISTS "Allow delete for users based on user_id" ON "public"."followers";
DROP policy IF EXISTS "Enable read access for all users" ON "public"."posts";
DROP policy IF EXISTS "Allow insert for authenticated users" ON "public"."posts";
DROP policy IF EXISTS "Allow update for users based on user_id" ON "public"."posts";
DROP policy IF EXISTS "Allow delete for users based on user_id" ON "public"."posts";
DROP policy IF EXISTS "Enable read access for all users" ON "public"."comments";
DROP policy IF EXISTS "Allow insert for authenticated users" ON "public"."comments";
DROP policy IF EXISTS "Allow read access for user to their own donations" ON "public"."donations";
DROP policy IF EXISTS "Allow insert for authenticated users" ON "public"."donations";
DROP policy IF EXISTS "Enable read access for all users" ON public.competitions;
DROP policy IF EXISTS "Enable read access for all users" ON public.internships;
DROP POLICY IF EXISTS "Allow read access for user to their own entries" ON public.competition_entries;
DROP POLICY IF EXISTS "Allow insert for authenticated users" ON public.competition_entries;
DROP POLICY IF EXISTS "Allow read access to participants" ON public.chat_rooms;
DROP POLICY IF EXISTS "Allow read access to participants" ON public.chat_participants;
DROP POLICY IF EXISTS "Allow read access to participants" ON public.chat_messages;
DROP POLICY IF EXISTS "Allow insert for participants" ON public.chat_messages;
DROP POLICY IF EXISTS "Enable read access for all users" ON "public"."support_tickets";
DROP POLICY IF EXISTS "Allow insert for authenticated users" ON "public"."support_tickets";
DROP POLICY IF EXISTS "Allow update for admins" ON "public"."support_tickets";
DROP POLICY IF EXISTS "Enable read for admins" ON "public"."audit_log";
DROP POLICY IF EXISTS "Enable read/write for admins" ON "public"."platform_settings";
DROP POLICY IF EXISTS "Enable read for users of their own orders" ON public.orders;
DROP POLICY IF EXISTS "Enable read for vendors of their own orders" ON public.orders;
DROP POLICY IF EXISTS "Enable read for order participants" ON public.order_items;

-- Drop Tables if they exist
DROP TABLE IF EXISTS public.order_items;
DROP TABLE IF EXISTS public.orders;
DROP TABLE IF EXISTS public.donations;
DROP TABLE IF EXISTS public.support_tickets;
DROP TABLE IF EXISTS public.audit_log;
DROP TABLE IF EXISTS public.platform_settings;
DROP TABLE IF EXISTS public.competition_entries;
DROP TABLE IF EXISTS public.competitions;
DROP TABLE IF EXISTS public.internships;
DROP TABLE IF EXISTS public.likes;
DROP TABLE IF EXISTS public.comments;
DROP TABLE IF EXISTS public.posts;
DROP TABLE IF EXISTS public.followers;
DROP TABLE IF EXISTS public.notifications;
DROP TABLE IF EXISTS public.products;
DROP TABLE IF EXISTS public.chat_messages;
DROP TABLE IF EXISTS public.chat_participants;
DROP TABLE IF EXISTS public.chat_rooms;
DROP TABLE IF EXISTS public.profiles;


-- Create profiles table
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text,
    avatar_url text,
    handle text UNIQUE,
    bio text,
    role text DEFAULT 'student'::text,
    contact_number text,
    opening_hours text,
    vendor_categories text[],
    banner_url text
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Create chat_rooms table
CREATE TABLE public.chat_rooms (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE public.chat_rooms ENABLE ROW LEVEL SECURITY;

-- Create chat_participants table
CREATE TABLE public.chat_participants (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    room_id uuid NOT NULL REFERENCES public.chat_rooms(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE (room_id, user_id)
);
ALTER TABLE public.chat_participants ENABLE ROW LEVEL SECURITY;

-- Create chat_messages table
CREATE TABLE public.chat_messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    room_id uuid REFERENCES public.chat_rooms(id) ON DELETE CASCADE,
    user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE
);
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;

-- Create products table
CREATE TABLE public.products (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    price real NOT NULL,
    image_url text,
    category text NOT NULL,
    seller_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    description text
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Create notifications table
CREATE TABLE public.notifications (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    type text NOT NULL,
    post_id integer,
    is_read boolean DEFAULT false
);
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- Create followers table
CREATE TABLE public.followers (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    follower_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    following_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    UNIQUE(follower_id, following_id)
);
ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;

-- Create posts table
CREATE TABLE public.posts (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE
);
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- Create comments table
CREATE TABLE public.comments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    post_id integer NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE
);
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

-- Create likes table
CREATE TABLE public.likes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    post_id integer NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    UNIQUE(user_id, post_id)
);
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

-- Create donations table
CREATE TABLE public.donations (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid REFERENCES public.profiles(id),
    amount integer NOT NULL,
    currency character varying(3) NOT NULL,
    razorpay_payment_id text UNIQUE
);
ALTER TABLE public.donations ENABLE ROW LEVEL SECURITY;

-- Create competitions table
CREATE TABLE public.competitions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    title text NOT NULL,
    description text,
    prize integer,
    entry_fee integer DEFAULT 0,
    deadline timestamp with time zone,
    image_url text,
    details_pdf_url text
);
ALTER TABLE public.competitions ENABLE ROW LEVEL SECURITY;

-- Create competition_entries table
CREATE TABLE public.competition_entries (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    competition_id bigint NOT NULL REFERENCES public.competitions(id) ON DELETE CASCADE,
    razorpay_payment_id text,
    UNIQUE(user_id, competition_id)
);
ALTER TABLE public.competition_entries ENABLE ROW LEVEL SECURITY;

-- Create internships table
CREATE TABLE public.internships (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    role text,
    company text,
    stipend integer,
    stipend_period text,
    location text,
    deadline timestamp with time zone,
    image_url text,
    details_pdf_url text,
    description text
);
ALTER TABLE public.internships ENABLE ROW LEVEL SECURITY;

-- Create support_tickets table
CREATE TABLE public.support_tickets (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    category text NOT NULL,
    subject text NOT NULL,
    description text NOT NULL,
    status text DEFAULT 'Open'::text,
    priority text DEFAULT 'Medium'::text,
    screenshot_url text
);
ALTER TABLE public.support_tickets ENABLE ROW LEVEL SECURITY;

-- Create audit_log table
CREATE TABLE public.audit_log (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    admin_id uuid REFERENCES public.profiles(id),
    action text NOT NULL,
    details text
);
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

-- Create platform_settings table
CREATE TABLE public.platform_settings (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key text NOT NULL UNIQUE,
    value jsonb,
    description text
);
ALTER TABLE public.platform_settings ENABLE ROW LEVEL SECURITY;

-- Create orders table
CREATE TABLE public.orders (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    buyer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    vendor_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    total_amount real NOT NULL,
    razorpay_payment_id text UNIQUE,
    status text DEFAULT 'Pending'::text
);
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

-- Create order_items table
CREATE TABLE public.order_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    order_id bigint NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
    product_id bigint NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    quantity integer NOT NULL,
    price real NOT NULL
);
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;


-- POLICIES --

-- Profiles
CREATE POLICY "Enable read access for all users" ON "public"."profiles" FOR SELECT USING (true);
CREATE POLICY "Allow update for a user's own profile" ON "public"."profiles" FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Chat
CREATE POLICY "Allow read access to participants" ON "public"."chat_rooms" FOR SELECT USING (EXISTS (SELECT 1 FROM public.chat_participants WHERE chat_participants.room_id = chat_rooms.id AND chat_participants.user_id = auth.uid()));
CREATE POLICY "Allow read access to participants" ON "public"."chat_participants" FOR SELECT USING (EXISTS (SELECT 1 FROM public.chat_participants cp2 WHERE cp2.room_id = chat_participants.room_id AND cp2.user_id = auth.uid()));
CREATE POLICY "Allow read access to participants" ON "public"."chat_messages" FOR SELECT USING (EXISTS (SELECT 1 FROM public.chat_participants WHERE chat_participants.room_id = chat_messages.room_id AND chat_participants.user_id = auth.uid()));
CREATE POLICY "Allow insert for participants" ON "public"."chat_messages" FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.chat_participants WHERE chat_participants.room_id = chat_messages.room_id AND chat_participants.user_id = auth.uid()));

-- Products
CREATE POLICY "Allow read access to all users" ON "public"."products" FOR SELECT USING (true);
CREATE POLICY "Allow insert for authenticated users" ON "public"."products" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow update for users based on user_id" ON "public"."products" FOR UPDATE USING (auth.uid() = seller_id);
CREATE POLICY "Allow delete for users based on user_id" ON "public"."products" FOR DELETE USING (auth.uid() = seller_id);

-- Notifications
CREATE POLICY "Allow read access for user to their own notifications" ON "public"."notifications" FOR SELECT USING (auth.uid() = user_id);

-- Followers
CREATE POLICY "Allow read access for user to their own followers" ON "public"."followers" FOR SELECT USING (true);
CREATE POLICY "Allow insert for authenticated users" ON "public"."followers" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow delete for users based on user_id" ON "public"."followers" FOR DELETE USING (auth.uid() = follower_id);

-- Posts
CREATE POLICY "Enable read access for all users" ON "public"."posts" FOR SELECT USING (true);
CREATE POLICY "Allow insert for authenticated users" ON "public"."posts" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow update for users based on user_id" ON "public"."posts" FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow delete for users based on user_id" ON "public"."posts" FOR DELETE USING (auth.uid() = user_id);

-- Comments
CREATE POLICY "Enable read access for all users" ON "public"."comments" FOR SELECT USING (true);
CREATE POLICY "Allow insert for authenticated users" ON "public"."comments" FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Likes
CREATE POLICY "Allow read access for user to their own likes" ON "public"."likes" FOR SELECT USING (true);
CREATE POLICY "Allow insert for authenticated users" ON "public"."likes" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow delete for users based on user_id" ON "public"."likes" FOR DELETE USING (auth.uid() = user_id);

-- Donations
CREATE POLICY "Allow read access for user to their own donations" ON "public"."donations" FOR SELECT USING (auth.uid() = user_id OR get_user_role() = 'admin');
CREATE POLICY "Allow insert for authenticated users" ON "public"."donations" FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Competitions/Internships
CREATE POLICY "Enable read access for all users" ON public.competitions FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON public.internships FOR SELECT USING (true);
CREATE POLICY "Allow read access for user to their own entries" ON public.competition_entries FOR SELECT USING (auth.uid() = user_id OR get_user_role() = 'admin');
CREATE POLICY "Allow insert for authenticated users" ON public.competition_entries FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Support Tickets
CREATE POLICY "Enable read access for all users" ON "public"."support_tickets" FOR SELECT USING (get_user_role() = 'admin' OR auth.uid() = user_id);
CREATE POLICY "Allow insert for authenticated users" ON "public"."support_tickets" FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow update for admins" ON "public"."support_tickets" FOR UPDATE USING (get_user_role() = 'admin');

-- Admin
CREATE POLICY "Enable read for admins" ON "public"."audit_log" FOR SELECT USING (get_user_role() = 'admin');
CREATE POLICY "Enable read/write for admins" ON "public"."platform_settings" FOR ALL USING (get_user_role() = 'admin');

-- Orders
CREATE POLICY "Enable read for users of their own orders" ON public.orders FOR SELECT USING (auth.uid() = buyer_id);
CREATE POLICY "Enable read for vendors of their own orders" ON public.orders FOR SELECT USING (auth.uid() = vendor_id);
CREATE POLICY "Enable read for order participants" ON public.order_items FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM public.orders
        WHERE orders.id = order_items.order_id AND (orders.buyer_id = auth.uid() OR orders.vendor_id = auth.uid())
    )
);


-- FUNCTIONS --

-- get_user_role function
CREATE OR REPLACE FUNCTION public.get_user_role()
RETURNS text
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT raw_user_meta_data->>'role' FROM auth.users WHERE id = auth.uid();
$$;


-- get_or_create_chat_room function
CREATE OR REPLACE FUNCTION public.get_or_create_chat_room(p_user_id1 uuid, p_user_id2 uuid)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_room_id uuid;
BEGIN
    -- Find a room where both users are participants
    SELECT room_id INTO v_room_id
    FROM chat_participants p1
    JOIN chat_participants p2 ON p1.room_id = p2.room_id
    WHERE p1.user_id = p_user_id1 AND p2.user_id = p_user_id2;

    -- If no room is found, create a new one
    IF v_room_id IS NULL THEN
        INSERT INTO chat_rooms DEFAULT VALUES RETURNING id INTO v_room_id;
        INSERT INTO chat_participants (room_id, user_id) VALUES (v_room_id, p_user_id1);
        INSERT INTO chat_participants (room_id, user_id) VALUES (v_room_id, p_user_id2);
    END IF;

    RETURN v_room_id;
END;
$$;


-- get_last_messages_for_rooms function
CREATE OR REPLACE FUNCTION public.get_last_messages_for_rooms(p_room_ids uuid[])
RETURNS TABLE(room_id uuid, content text, created_at timestamptz)
LANGUAGE sql
AS $$
    WITH ranked_messages AS (
      SELECT
        m.room_id,
        m.content,
        m.created_at,
        ROW_NUMBER() OVER(PARTITION BY m.room_id ORDER BY m.created_at DESC) as rn
      FROM chat_messages m
      WHERE m.room_id = ANY(p_room_ids)
    )
    SELECT
      rm.room_id,
      rm.content,
      rm.created_at
    FROM ranked_messages rm
    WHERE rm.rn = 1;
$$;


-- handle_new_user function to create a profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO public.profiles (id, full_name, role, handle, vendor_categories)
    VALUES (
        new.id,
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'role',
        COALESCE(new.raw_user_meta_data->>'handle', split_part(new.email, '@', 1) || '_' || (random() * 1000)::int),
        (select array_agg(elem::text) from jsonb_array_elements_text(new.raw_user_meta_data->'vendor_categories'))
    );
    RETURN new;
END;
$$;


-- TRIGGERS --

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create the trigger
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- Initial Data
INSERT INTO public.platform_settings (key, value, description)
VALUES 
  ('monetization', '{"charge_for_posts": false, "post_price": 10, "start_date": null}', 'Settings for charging users for marketplace listings.'),
  ('donation_goal', '50000', 'The monthly donation goal for the platform.')
ON CONFLICT (key) DO NOTHING;
